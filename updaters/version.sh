#! /usr/bin/env bash
set -euxo pipefail

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

source $SCRIPT_DIR/../utils.sh

ATTR_PATH=$1
BRANCH_NAME=$2
OLD_VERSION=$3
NEW_VERSION=$4

DERIVATION_FILE=$(EDITOR="echo" nix edit "$ATTR_PATH" -f .) || error_exit "Couldn't find derivation file."

# Skip packages that have special builders
if grep -q "buildGoPackage" "$DERIVATION_FILE"
then
    error_exit "Derivation contains buildGoPackage."
fi
if grep -q "buildRustCrate" "$DERIVATION_FILE"
then
    error_exit "Derivation contains buildRustCrate."
fi
if grep -q "buildPythonPackage" "$DERIVATION_FILE"
then
    error_exit "Derivation contains buildPythonPackage."
fi
if grep -q "buildRubyGem" "$DERIVATION_FILE"
then
    error_exit "Derivation contains buildRubyGem."
fi
if grep -q "bundlerEnv" "$DERIVATION_FILE"
then
    error_exit "Derivation contains bundlerEnv."
fi

# Make sure it hasn't been updated on master
grep "$OLD_VERSION" "$DERIVATION_FILE" || error_exit "Old version not present in master derivation file."

# Make sure it hasn't been updated on staging
git reset --hard
git checkout staging
git reset --hard upstream/staging
grep "$OLD_VERSION" "$DERIVATION_FILE" || error_exit "Old version not present in staging derivation file."

git checkout "$(git merge-base upstream/master upstream/staging)"

git checkout -B "$BRANCH_NAME"
OLD_HASH=$(nix eval -f . --raw "pkgs.$ATTR_PATH.src.drvAttrs.outputHash" || error_exit "Couldn't find old output hash at ATTR_PATH.src.drvAttrs.outputHash.")

sed -i "s/${OLD_VERSION//\./\\.}/$NEW_VERSION/g" "$DERIVATION_FILE" || error_exit "Could not replace OLD_VERSION with NEW_VERSION."

NEW_HASH=$(nix-prefetch-url -A "$ATTR_PATH.src" || error_exit "Could not prefetch new version URL.")

if [ "$OLD_HASH" = "$NEW_HASH" ]
then
    error_exit "Hashes equal; no update necessary"
fi

sed -i "s/$OLD_HASH/$NEW_HASH/g" "$DERIVATION_FILE" || error_exit "Could not replace OLD_HASH with NEW_HASH."

rm -f result*

nix build -f . "$ATTR_PATH" || error_exit "nix build failed."

RESULT=$(readlink ./result || readlink ./result-bin || error_exit "Couldn't find result link.")

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

CHECK_RESULT="$("$SCRIPT_DIR"/../check-result.sh "$RESULT" "$NEW_VERSION")"

MAINTAINERS=
if nix eval "(let pkgs = import ./. {}; in pkgs.$ATTR_PATH.meta.maintainers)" > /dev/null 2>&1
then
    maintainers=$(nix eval --raw '(let pkgs = import ./. {}; gh = m : m.github or ""; nonempty = s: s != ""; addat = s: "@"+s; in builtins.concatStringsSep " " (map addat (builtins.filter nonempty (map gh pkgs.'"${ATTR_NAME}"'.meta.maintainers))))')
    if [ -n "$maintainers" ]
    then
        MAINTAINERS="
cc $maintainers for review"
    fi
fi

git diff

COMMIT_MESSAGE="$ATTR_NAME: $OLD_VERSION -> $NEW_VERSION

Semi-automatic update generated by https://github.com/ryantm/nix-update tools. These checks were done:

- built on NixOS
$CHECK_RESULT"

git commit -am "$COMMIT_MESSAGE"

pull_request "$COMMIT_MESSAGE$MAINTAINERS"
